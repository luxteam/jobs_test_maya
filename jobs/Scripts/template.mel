// TODO: mb dived template for material test and other tests
source shelfCommands.mel;
source maya_benchmark_common.mel;

//Scene Information:
//configs:
global string $resultsDirectoryName = "{outputFolder}";
global string $testType = "{testType}";
global string $reportName = "report_mel.json";

// [0] project name
// [1] model name
// [2] additional script that are called before render
// [3] additional File Name identifier
global string $sceneRenderData[] = {{
{testsList}
}};

//gets material library path:
proc string getMatLibraryPath(){{
	python( "import sys" );
	python("import fireRender.rpr_material_browser");
	python("reload(fireRender.rpr_material_browser)");
	string $libraryP = python("fireRender.rpr_material_browser.getLibPath()");

	if (size($libraryP)==0){{
		//if material library is not installed:
		return "";
	}}

	return $libraryP;
}}

//////////////////////////
//Test Functions (Scenes):
//////////////////////////
proc mayaSceneTests(string $resultsDirectory, string $projectBase, string $resultFolder_color, string $resultFolder_opacity, string $useGPU[], string $sceneRenderData[]){{
	string $renderViewName = getRenderWindowPanel();
    int $j = 0;
	int $i = 0;

    // Run render tests
	float $startTime = 0;
	float $testTime = 0;
    for ($j = 0 ; $j<size($sceneRenderData) ; $j += 4) {{
		//clock start time:
		$startTime = `timerX`;

		string $projectFolderPath = $projectBase + $sceneRenderData[$j];
		string $sceneF = $sceneRenderData[$j+1];
		string $additionalFileNameId = $sceneRenderData[$j+3];
		string $sceneFile = substituteAllString($sceneF,".mb","") + $additionalFileNameId + ".jpg";
		string $additionalFuncCall = $sceneRenderData[$j+2];
		

		string $resultFileName_color = $resultFolder_color + $sceneFile;
		string $resultFileName_opacity = $resultFolder_opacity + $sceneFile;

		setProject($projectFolderPath);

		//open scene:
		openSceneFileAndSetRPRRender($sceneF,$useGPU);

		if (size($additionalFuncCall) > 0){{
			eval $additionalFuncCall;
		}}

		//we could use this for rendering animations.
		//however that would be not the same as batch rendering.
		currentTime -edit 0;

		//set RPR render to wait for render to finish:
		fireRender -waitForItTwo;

		// render current frame
		renderIntoNewWindow render;

		if (`filetest -f $resultFileName_color` == 0){{
			//delete previous image if exists:
			sysFile -delete ($resultFileName_color);
		}}
		if (`filetest -f $resultFileName_opacity` == 0){{
			//delete previous image if exists:
			sysFile -delete ($resultFileName_opacity);
		}}
		
		renderWindowEditor -edit  -dst "color" $renderViewName;
		renderWindowEditor -edit -com -writeImage $resultFileName_color $renderViewName;
		renderWindowEditor -edit  -dst "mask" $renderViewName;
		renderWindowEditor -edit -com -writeImage $resultFileName_opacity $renderViewName;

		//swap back to color so it can be viewed while rendering:
		renderWindowEditor -edit  -dst "color" $renderViewName;
		//calculate total test time:
		$testTime = `timerX -startTime $startTime`;

		global string $reportName;

		writeToJSONReport($resultsDirectory, $reportName, "\n {{");
		writeFullJsonReport($resultsDirectory, $sceneF, $sceneFile, $testTime, $useGPU, 1);
		if ($j+4 < size($sceneRenderData)){{
			writeToJSONReport($resultsDirectory, $reportName, "\n }},");
		}}
		else{{ 
			writeToJSONReport($resultsDirectory, $reportName, "\n }}");
		}}
		
		file -f -new;
	}}
}}

/////////////////////////////
//Test Functions (Materials):
/////////////////////////////
proc mayaMaterialTests(string $resultsDirectory, string $projectFolderPath, string $sceneFile, string $resultFolder, string $useGPU[], string $libraryPath, string $contentList[]){{
	setProject($projectFolderPath);
	
	string $renderViewNameMatTesting = getRenderWindowPanel();

	int $i = 0;
	int $j = 0;
	string $folderPath = "";
	string $xmlPath = "";
	string $subContentList[] = {{}};
	string $materialTestNode = "materialTestNode";
	string $materialTestNodeSG = "materialTestNodeSG";
	string $resultFileName = "";
	string $resultFilePath = "";
	float $startTime = 0;
	float $testTime = 0;

	for (;$i < size($contentList); $i++){{
		$folderPath = ($libraryPath + "/" + $contentList[$i]);
		if (`filetest -d $folderPath`){{
			//directory:
			$subContentList = `getFileList -folder $folderPath -filespec "*.xml"`;
			if (size($subContentList) == 0){{
				$subContentList = `getFileList -folder $folderPath -filespec "*.XML"`;
			}}
			$j = 0;
			for (;$j < size($subContentList);$j++){{
				//clock start time:
				$startTime = `timerX`;

				$resultFileName = $contentList[$i] + ".jpg";
				$resultFilePath = $resultFolder + $resultFileName;

				//open material test scene again to flush out changes:
				openSceneFileAndSetRPRRender($sceneFile,$useGPU);

				$xmlPath = $folderPath + "/" + $subContentList[$j];
				RPRXMLImport -file $xmlPath -importImages false -mn $materialTestNode;
				// probe03 object on scene
				select -r Probe03;
				sets -e -forceElement $materialTestNodeSG;

				fireRender -waitForItTwo;

				renderIntoNewWindow render;

				if (`filetest -f $resultFilePath` == 0){{
					//delete previous image if exists:
					sysFile -delete ($resultFilePath);
				}}

				renderWindowEditor -edit  -dst "color" $renderViewNameMatTesting;
				renderWindowEditor -edit -com -writeImage $resultFilePath $renderViewNameMatTesting;

				$testTime = `timerX -startTime $startTime`;

				global string $reportName;

				writeToJSONReport($resultsDirectory, $reportName, "\n {{");
				writeFullJsonReport($resultsDirectory, $sceneFile, $resultFileName, $testTime, $useGPU, 0);
				if ($i+1 < size($contentList)){{
					writeToJSONReport($resultsDirectory, $reportName, "}},");
				}}
				else{{
					writeToJSONReport($resultsDirectory, $reportName, "}}");
				}}

				file -f -new;
			}}
		}}
	}}
}}

//main function
global proc main(int $wantedTests[]){{

	global string $reportName;
	if (`filetest -f $reportName` == 0){{
		//delete previous report if exists:
		sysFile -delete ($reportName);
	}}

	//check plugin loaded
	if( `pluginInfo -query -loaded RadeonProRender` == 0){{
    	loadPlugin RadeonProRender;
	}}
    // updateRendererUI;
    // updateRenderOverride;

    // unifiedRenderGlobalsWindow;
    // updateRendererUI;
    // updateRenderOverride;

	// Force the window size to SPEC APC definition 1920x1024 30 pixels are not used to make way for window boarders
	// window -e -tlc 0 0 -wh 1920 1050 MayaWindow;

	// string $scriptPath = `whatIs mayaBenchmark`;
	$scriptPath = stringRemovePrefix (`whatIs mayaBenchmark`, "Mel procedure found in: ");
	// string $scriptPathTokens[];
	// tokenize $scriptPath " " $scriptPathTokens;
	// tokenize $scriptPath "\n" $scriptPathTokens;

	// string $pathArray[] = stringToStringArray($scriptPathTokens[4], "/");
	string $pathArray[] = stringToStringArray($scriptPath, "/");
	string $resultsDirectory = "";
	string $projectBase = "";
	
	$projectBase = "{projectBase}" + "/";

	int $a = 0;
	for ($a = 0; $a < size($pathArray)-1; $a++){{ 		//-1 to delete *.mel name
		$resultsDirectory = $resultsDirectory + $pathArray[$a] + "/";
	}}
	
	global string $sceneRenderData[];
	global string $testType;
	string $resultColor = $resultsDirectory + "Color/";
	string $resultOpacity = $resultsDirectory + "Opacity/";


	string $temp = intArrayToString($wantedTests, " ");
	string $useGPU[] = stringToStringArray($temp, " ");

	if (`match "Materials" $testType` == "Materials"){{
		if (`filetest -d $resultColor` == 0){{
			sysFile -makeDir $resultColor;
		}}

		string $matProjectFolderPath = $projectBase + "MaterialLibraryScene/";
		string $matSceneName = "MaterialTestScene.mb";
		string $libPath = getMatLibraryPath();

		//all materials in library - list of folders	
		string $contentList[];
		global string $sceneRenderData[];
		if (`strcmp $sceneRenderData[0] "*"`){{
			$contentList = $sceneRenderData;
		}}
		else{{
			$contentList = `getFileList -folder $libPath`;
		}}

		createExpectedLogMaterials("expected.json", $resultsDirectory, $contentList, $useGPU);

		writeToJSONReport($resultsDirectory, $reportName, "[");
		mayaMaterialTests($resultsDirectory, $matProjectFolderPath, $matSceneName, $resultColor, $useGPU, $libPath, $contentList);
		writeToJSONReport($resultsDirectory, $reportName, "\n]");	
	}}else{{
		if (`filetest -d $resultColor` == 0){{
			sysFile -makeDir $resultColor;
		}}
		if (`filetest -d $resultOpacity` == 0){{
			sysFile -makeDir $resultOpacity;
		}}

		createExpectedLog("expected.json", $resultsDirectory, $sceneRenderData, $useGPU);

		writeToJSONReport($resultsDirectory, $reportName, "[");
		mayaSceneTests($resultsDirectory, $projectBase, $resultColor, $resultOpacity, $useGPU, $sceneRenderData);
		writeToJSONReport($resultsDirectory, $reportName, "\n]");	
	}}

	file -f -new;

	// close file with script editor trace
	string $traceFile = getenv( "MAYA_CMD_FILE_OUTPUT" );
	int $descriptor = `cmdFileOutput -o $traceFile -q`;
	if ( -1 != $descriptor ) {{
	    cmdFileOutput -close $descriptor;
	}}

	evalDeferred("quit -abort");
}}